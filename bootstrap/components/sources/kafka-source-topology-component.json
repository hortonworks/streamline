{
  "type": "SOURCE",
  "name": "Kafka",
  "subType": "KAFKA",
  "streamingEngine": "STORM",
  "builtin": true,
  "fieldHintProviderClass": "com.hortonworks.streamline.streams.cluster.bundle.impl.KafkaBundleHintProvider",
  "transformationClass": "com.hortonworks.streamline.streams.layout.storm.KafkaSpoutFluxComponent",
  "mavenDeps": "org.apache.kafka:kafka-clients:0.10.2.1,org.apache.storm:storm-kafka-client:STORM_VERSION^org.slf4j:slf4j-log4j12^log4j:log4j^org.apache.zookeeper:zookeeper^org.apache.kafka:kafka-clients",
  "topologyComponentUISpecification": {
    "fields": [
      {
        "uiName": "Security Protocol",
        "fieldName": "securityProtocol",
        "isOptional": false,
        "tooltip": "Protocol to be used to communicate with Kafka brokers",
        "type": "enumstring",
        "options": []
      },
      {
        "uiName": "Bootstrap servers",
        "fieldName": "bootstrapServers",
        "isOptional": false,
        "tooltip": "A comma separated string of host:port for Kafka brokers",
        "type": "string",
        "hint": "dependsOn-securityProtocol"
      },
      {
        "uiName": "Kafka Topic",
        "fieldName": "topic",
        "isOptional": false,
        "tooltip": "Kafka topic to read data from",
        "type": "enumstring",
        "options": [],
        "hint": "schema,override"
      },
      {
        "uiName": "Reader Schema Branch",
        "fieldName": "schemaBranch",
        "isOptional": false,
        "tooltip": "Schema branch to be used fetching for reader schema versions. Default branch is MASTER",
        "type": "enumstring",
        "options": [],
        "hint": "dependsOn-topic,schemaBranch"
      },
      {
        "uiName": "Reader Schema Version",
        "fieldName": "readerSchemaVersion",
        "isOptional": false,
        "tooltip": "Version of schema for topic to use for deserializing the message. Default is version used by kafka producer to write the message",
        "type": "enumstring",
        "options": [],
        "hint": "dependsOn-schemaBranch,schemaVersion"
      },
      {
        "uiName": "Consumer Group Id",
        "fieldName": "consumerGroupId",
        "isOptional": false,
        "tooltip": "A unique string that identifies the consumer group this source belongs to. It is used to keep track of consumer offset",
        "type": "string"
      },
      {
        "uiName": "Kerberos client principal",
        "fieldName": "principal",
        "isOptional": true,
        "tooltip": "Client principal to use to connect to brokers while using SASL GSSAPI mechanism for Kerberos",
        "type": "string",
        "hint": "security_kerberos_required",
        "defaultValue": null
      },
      {
        "uiName": "Kerberos keytab file",
        "fieldName": "keytab",
        "isOptional": true,
        "tooltip": "Keytab file location on worker node containing the secret key for client principal while using SASL GSSAPI mechanism for Kerberos",
        "type": "string",
        "hint": "security_kerberos_required",
        "defaultValue": null
      },
      {
        "uiName": "Kafka service name",
        "fieldName": "kafkaServiceName",
        "isOptional": true,
        "tooltip": "Service name that Kafka broker is running as",
        "type": "string",
        "hint": "security_kerberos_required",
        "defaultValue": null
      },
      {
        "uiName": "Fetch minimum bytes",
        "fieldName": "fetchMinimumBytes",
        "isOptional": true,
        "tooltip": "The minimum number of bytes the broker should return for a fetch request",
        "type": "string",
        "defaultValue": "1"
      },
      {
        "uiName": "Maximum fetch bytes per partition",
        "fieldName": "fetchMaximumBytesPerPartition",
        "isOptional": true,
        "tooltip": "The maximum amount of data per-partition the broker will return",
        "type": "string",
        "defaultValue": "1048576"
      },
      {
        "uiName": "Maximum records per poll",
        "fieldName": "maxRecordsPerPoll",
        "isOptional": true,
        "tooltip": "The maximum number of records a poll will return",
        "type": "string",
        "defaultValue": "500"
      },
      {
        "uiName": "Poll timeout(ms)",
        "fieldName": "pollTimeoutMs",
        "isOptional": true,
        "tooltip": "Time in milliseconds spent waiting in poll if data is not available",
        "type": "number",
        "defaultValue": 200
      },
      {
        "uiName": "Offset commit period(ms)",
        "fieldName": "offsetCommitPeriodMs",
        "isOptional": true,
        "tooltip": "Period in milliseconds at which offsets are committed",
        "type": "number",
        "defaultValue": 30000
      },
      {
        "uiName": "Maximum uncommitted offsets",
        "fieldName": "maximumUncommittedOffsets",
        "isOptional": true,
        "tooltip": "Defines the max number of polled records that can be pending commit, before another poll can take place",
        "type": "number",
        "defaultValue": 10000000
      },
      {
        "uiName": "First poll offset strategy",
        "fieldName": "firstPollOffsetStrategy",
        "isOptional": true,
        "tooltip": "Offset used by the Kafka spout in the first poll to Kafka broker",
        "type": "enumstring",
        "options": ["EARLIEST", "LATEST", "UNCOMMITTED_EARLIEST", "UNCOMMITTED_LATEST"],
        "defaultValue": "UNCOMMITTED_EARLIEST"
      },
      {
        "uiName": "Partition refresh period(ms)",
        "fieldName": "partitionRefreshPeriodMs",
        "isOptional": true,
        "tooltip": "Period in milliseconds at which Kafka will be polled for new topics and/or partitions",
        "type": "number",
        "defaultValue": 2000
      },
      {
        "uiName": "Emit null tuples?",
        "fieldName": "emitNullTuples",
        "isOptional": true,
        "tooltip": "A flag to indicate if null tuples should be emitted to downstream components or not",
        "type": "boolean",
        "defaultValue": false
      },
      {
        "uiName": "First retry delay(ms)",
        "fieldName": "retryInitialDelayMs",
        "isOptional": true,
        "tooltip": "Interval delay in milliseconds for first retry for a failed Kafka spout message",
        "type": "number",
        "defaultValue": 0
      },
      {
        "uiName": "Retry delay period(ms)",
        "fieldName": "retryDelayPeriodMs",
        "isOptional": true,
        "tooltip": "Retry delay period(geometric progression) in milliseconds for second and subsequent retries for a failed Kafka spout message",
        "type": "number",
        "defaultValue": 2
      },
      {
        "uiName": "Maximum retries",
        "fieldName": "maximumRetries",
        "isOptional": true,
        "tooltip": "Maximum number of times a failed message is retried before it is acked and committed",
        "type": "number",
        "defaultValue": 2147483647
      },
      {
        "uiName": "Maximum retry delay(ms)",
        "fieldName": "retryDelayMaximumMs",
        "isOptional": true,
        "tooltip": "Maximum interval in milliseconds to wait before successive retries for a failed Kafka spout message",
        "type": "number",
        "defaultValue": 10000
      },
      {
        "uiName": "SSL keystore location",
        "fieldName": "sslKeystoreLocation",
        "isOptional": true,
        "tooltip": "The location of the key store file",
        "type": "string",
        "hint": "security_ssl",
        "defaultValue": null
      },
      {
        "uiName": "SSL keystore password",
        "fieldName": "sslKeystorePassword",
        "isOptional": true,
        "tooltip": "The store password for the key store file",
        "type": "string",
        "hint": "security_ssl,password",
        "defaultValue": null
      },
      {
        "uiName": "SSL key password",
        "fieldName": "sslKeyPassword",
        "isOptional": true,
        "tooltip": "The password of the private key in the key store file",
        "type": "string",
        "hint": "security_ssl,password",
        "defaultValue": null
      },
      {
        "uiName": "SSL truststore location",
        "fieldName": "sslTruststoreLocation",
        "isOptional": true,
        "tooltip": "The location of the trust store file",
        "type": "string",
        "hint": "security_ssl_required",
        "defaultValue": null
      },
      {
        "uiName": "SSL truststore password",
        "fieldName": "sslTruststorePassword",
        "isOptional": true,
        "tooltip": "The password for the trust store file",
        "type": "string",
        "hint": "security_ssl_required,password",
        "defaultValue": null
      },
      {
        "uiName": "SSL enabled protocols",
        "fieldName": "sslEnabledProtocols",
        "isOptional": true,
        "tooltip": "Comma separated list of protocols enabled for SSL connections",
        "type": "string",
        "hint": "security_ssl",
        "defaultValue": null
      },
      {
        "uiName": "SSL keystore type",
        "fieldName": "sslKeystoreType",
        "isOptional": true,
        "tooltip": "File format of keystore file",
        "type": "string",
        "hint": "security_ssl",
        "defaultValue": "JKS"
      },
      {
        "uiName": "SSL truststore type",
        "fieldName": "sslTruststoreType",
        "isOptional": true,
        "tooltip": "File format of truststore file",
        "type": "string",
        "hint": "security_ssl",
        "defaultValue": "JKS"
      },
      {
        "uiName": "SSL protocol",
        "fieldName": "sslProtocol",
        "isOptional": true,
        "tooltip": "SSL protocol used to generate SSLContext",
        "type": "string",
        "hint": "security_ssl",
        "defaultValue": "TLS"
      },
      {
        "uiName": "SSL provider",
        "fieldName": "sslProvider",
        "isOptional": true,
        "tooltip": "Security provider used for SSL connections. Default value is default security provider for JVM",
        "type": "string",
        "hint": "security_ssl",
        "defaultValue": null
      },
      {
        "uiName": "SSL cipher suites",
        "fieldName": "sslCipherSuites",
        "isOptional": true,
        "tooltip": "Comma separated list of cipher suites. This is a named combination of authentication, encryption, MAC and key exchange algorithm used to negotiate the security settings for a network connection using TLS or SSL network protocol. By default all the available cipher suites are supported",
        "type": "string",
        "hint": "security_ssl",
        "defaultValue": null
      },
      {
        "uiName": "SSL endpoint identification algorithm",
        "fieldName": "sslEndpointIdAlgo",
        "isOptional": true,
        "tooltip": "The endpoint identification algorithm to validate server hostname using server certificate",
        "type": "string",
        "hint": "security_ssl",
        "defaultValue": null
      },
      {
        "uiName": "SSL key manager algorithm",
        "fieldName": "sslKeyManagerAlgo",
        "isOptional": true,
        "tooltip": "The algorithm used by key manager factory for SSL connections",
        "type": "string",
        "hint": "security_ssl",
        "defaultValue": "SunX509"
      },
      {
        "uiName": "SSL secure random implementation",
        "fieldName": "sslSecureRandomImpl",
        "isOptional": true,
        "tooltip": "The SecureRandom PRNG implementation to use for SSL cryptography operations",
        "type": "string",
        "hint": "security_ssl",
        "defaultValue": null
      },
      {
        "uiName": "SSL trust manager algorithm",
        "fieldName": "sslTrustManagerAlgo",
        "isOptional": true,
        "tooltip": "The algorithm used by trust manager factory for SSL connections. Default value is the trust manager factory algorithm configured for the Java Virtual Machine",
        "type": "string",
        "hint": "security_ssl",
        "defaultValue": "PKIX"
      },
      {
        "uiName": "Parallelism",
        "fieldName": "parallelism",
        "isOptional": true,
        "tooltip": "Parallelism hint for Kafka spout",
        "type": "number",
        "defaultValue": 1,
        "min": 1,
        "hint": "hidden"
      },
      {
        "uiName": "Auto commit interval (ms)",
        "fieldName": "autoCommitIntervalMs",
        "isOptional": true,
        "tooltip": "The frequency in ms that the consumer offsets are committed. (when autoCommitEnable is true)",
        "type": "number",
        "defaultValue": 5000
      },
      {
        "uiName": "Auto offset Reset",
        "fieldName": "autoOffsetReset",
        "isOptional": true,
        "tooltip": "What to do when there is no initial offset in Kafka or if an offset is out of range: earliest : automatically reset the offset to the earliest offset; latest : automatically reset the offset to the latest offset; none: throw exception to the consumer if no previous offset is found for the consumer's group; anything else: throw exception to the consumer.",
        "type": "string",
        "defaultValue": "latest"
      },
      {
        "uiName": "Check the CRC32 of the records",
        "fieldName": "checkCrcs",
        "isOptional": true,
        "tooltip": "Automatically check the CRC32 of the records consumed. This ensures no on-the-wire or on-disk corruption to the messages occurred. This check adds some overhead, so it may be disabled in cases seeking extreme performance.",
        "type": "boolean",
        "defaultValue": true
      },
      {
        "uiName": "Auto commit",
        "fieldName": "autoCommitEnable",
        "isOptional": true,
        "tooltip": "If true the consumer's offset will be periodically committed in the background.",
        "type": "boolean",
        "defaultValue": true
      },
      {
        "uiName": "Fetch maximum bytes",
        "fieldName": "fetchMaxBytes",
        "isOptional": true,
        "tooltip": "The maximum amount of data the server should return for a fetch request This is not an absolute maximum, if the first message in the first non-empty partition of the fetch is larger than this value, the message will still be returned to ensure that the consumer can make progress. The maximum message size accepted by the broker is defined via message.max.bytes (broker config) or max.message.bytes (topic config). Note that the consumer performs multiple fetches in parallel.",
        "type": "number",
        "defaultValue": 52428800
      },
      {
        "uiName": "Maximum fetch wait (ms)",
        "fieldName": "fetchWaitMaxMs",
        "isOptional": true,
        "tooltip": "The maximum amount of time the server will block before answering the fetch request if there isn’t sufficient data to immediately satisfy fetchMinimumBytes",
        "type": "number",
        "defaultValue": 500
      },
      {
        "uiName": "Heartbeat interval (ms)",
        "fieldName": "heartbeatIntervalMs",
        "isOptional": true,
        "tooltip": "The expected time between heartbeats to the consumer coordinator when using Kafka’s group management facilities. Heartbeats are used to ensure that the consumer’s session stays active and to facilitate rebalancing when new consumers join or leave the group. The value must be set lower than sessionTimeoutMs, but typically should be set no higher than 1/3 of that value. It can be adjusted even lower to control the expected time for normal rebalances.",
        "type": "number",
        "defaultValue": 3000
      },
      {
        "uiName": "Max poll interval (ms)",
        "fieldName": "maxPollIntervalMs",
        "isOptional": true,
        "tooltip": "The maximum delay between invocations of poll() when using consumer group management. This places an upper bound on the amount of time that the consumer can be idle before fetching more records. If poll() is not called before expiration of this timeout, then the consumer is considered failed and the group will rebalance in order to reassign the partitions to another member.",
        "type": "number",
        "defaultValue": 300000
      },
      {
        "uiName": "Metadata Max Age",
        "fieldName": "metadataMaxAge",
        "isOptional": true,
        "tooltip": "Time in milliseconds after which a metadata fetch request is forced.",
        "type": "number",
        "defaultValue": 300000
      },
      {
        "uiName": "Receive Buffer Size",
        "fieldName": "receiveBufferSize",
        "isOptional": true,
        "tooltip": "Size in bytes of TCP receive buffer (SO_RCVBUF) to use when reading data.",
        "type": "number",
        "defaultValue": 65536
      },
      {
        "uiName": "Reconnect Backoff (ms)",
        "fieldName": "reconnectBackoff",
        "isOptional": true,
        "tooltip": "Amount of time in milliseconds to wait before attempting to reconnect to a host.",
        "type": "number",
        "defaultValue": 50
      },
      {
        "uiName": "Request Timeout (ms)",
        "fieldName": "requestTimeout",
        "isOptional": true,
        "tooltip": "The configuration controls the maximum amount of time the client will wait for the response of a request. If the response is not received before the timeout elapses the client will resend the request if necessary or fail the request if retries are exhausted.",
        "type": "number",
        "defaultValue": 30000
      },
      {
        "uiName": "Retry Backoff (ms)",
        "fieldName": "retryBackoff",
        "isOptional": true,
        "tooltip": "Amount of time in milliseconds to wait before attempting to retry a failed fetch request. This avoids repeatedly sending requests in a tight loop under some failure scenarios.",
        "type": "number",
        "defaultValue": 100
      },
      {
        "uiName": "Send Buffer Size (bytes)",
        "fieldName": "sendBufferSize",
        "isOptional": true,
        "tooltip": "The size of the TCP send buffer (SO_SNDBUF) to use when sending data. If the value is -1, the OS default will be used.",
        "type": "number",
        "defaultValue": 131072
      },
      {
        "uiName": "Session timout (ms)",
        "fieldName": "sessionTimoutMs",
        "isOptional": true,
        "tooltip": "The timeout used to detect consumer failures when using Kafka's group management facility. The consumer sends periodic heartbeats to indicate its liveness to the broker. If no heartbeats are received by the broker before the expiration of this session timeout, then the broker will remove this consumer from the group and initiate a rebalance.",
        "type": "number",
        "defaultValue": 10000
      }
    ]
  }
}
